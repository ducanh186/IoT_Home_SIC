/*
 * ESP32 Smart Door System
 * Hệ thống cửa thông minh với cảm biến phát hiện người
 * 
 * Features:
 * - Tự động mở cửa khi phát hiện người
 * - Tự động đóng cửa sau khoảng thời gian không có người
 * - Điều khiển thủ công qua MQTT/Web dashboard
 * - Smooth servo movement
 * - Real-time status reporting
 * 
 * Hardware:
 * - ESP32 DevKit
 * - Servo SG90 (Pin 18)
 * - IR Sensor ARD2-2233 (3 pins: VCC, GND, OUT → Pin 16)
 * - WiFi: VIETTEL/12345678
 * - MQTT: 192.168.1.10:1883
 */

#include <WiFi.h>
#include <PubSubClient.h>
#include <ESP32Servo.h>
#include <ArduinoJson.h>

// === NETWORK CONFIGURATION ===
const char* ssid = "VIETTEL";
const char* password = "12345678";
const char* mqtt_server = "192.168.1.10";
const int mqtt_port = 1883;
const char* mqtt_user = "pi";
const char* mqtt_pass = "1234";

// === MQTT TOPICS ===
const char* topic_cmd = "door/cmd";
const char* topic_status = "door/status";
const char* topic_sensor = "door/sensor";

// === HARDWARE PINS ===
#define SERVO_PIN 18
#define SENSOR_PIN 16     // Digital input pin for IR sensor OUT

// === SERVO SETTINGS ===
#define DOOR_CLOSED 0    // 0° = cửa đóng
#define DOOR_OPEN 90     // 90° = cửa mở
#define SMOOTH_DELAY 20  // ms delay between steps for smooth movement

// === TIMING SETTINGS ===
#define PRESENCE_TIMEOUT 20000    // 20 giây không người → đóng cửa
#define MANUAL_OVERRIDE 60000     // 60 giây override sau lệnh thủ công
#define HEARTBEAT_INTERVAL 30000  // 30 giây gửi heartbeat
#define SENSOR_READ_INTERVAL 500  // 500ms đọc sensor

// === GLOBAL VARIABLES ===
WiFiClient espClient;
PubSubClient client(espClient);
Servo doorServo;

// State variables
int currentAngle = DOOR_CLOSED;
bool doorState = false;  // false = closed, true = open
bool presenceDetected = false;
float lastDistance = 0;
unsigned long lastPersonSeen = 0;
unsigned long lastHeartbeat = 0;
unsigned long lastSensorRead = 0;
unsigned long manualOverrideUntil = 0;
String lastAction = "system_start";

// === SETUP FUNCTIONS ===
void setup() {
  Serial.begin(115200);
  Serial.println("\n=== ESP32 Smart Door System Starting ===");
  
  // Initialize sensor pin
  pinMode(SENSOR_PIN, INPUT);
  Serial.println("IR Sensor pin initialized");
  
  // Initialize servo
  doorServo.attach(SERVO_PIN);
  doorServo.write(DOOR_CLOSED);
  currentAngle = DOOR_CLOSED;
  Serial.println("Servo initialized at 0° (closed)");
  
  // Connect to WiFi
  setupWiFi();
  
  // Setup MQTT
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(mqttCallback);
  
  Serial.println("=== System Ready ===\n");
}

void setupWiFi() {
  delay(10);
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected!");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi connection failed!");
  }
}

// === MAIN LOOP ===
void loop() {
  // Maintain MQTT connection
  if (!client.connected()) {
    reconnectMQTT();
  }
  client.loop();
  
  // Read sensor data
  if (millis() - lastSensorRead >= SENSOR_READ_INTERVAL) {
    readSensorData();
    lastSensorRead = millis();
  }
  
  // Check for automatic door control
  checkAutomaticControl();
  
  // Send heartbeat
  if (millis() - lastHeartbeat >= HEARTBEAT_INTERVAL) {
    sendHeartbeat();
    lastHeartbeat = millis();
  }
  
  delay(50); // Small delay to prevent watchdog issues
}

// === SENSOR FUNCTIONS ===
void readSensorData() {
  // Read digital IR sensor (3-pin: VCC, GND, OUT)
  // NOTE: Cảm biến này có logic ngược - LOW = có người, HIGH = không có người
  bool sensorReading = digitalRead(SENSOR_PIN);
  bool currentPresence = !sensorReading; // Đảo ngược logic
  
  // Check for presence change
  if (currentPresence != presenceDetected) {
    presenceDetected = currentPresence;
    
    if (presenceDetected) {
      // Person detected (sensor LOW)
      lastPersonSeen = millis();
      lastDistance = 1.0; // Default distance for digital sensor
      Serial.println("Person detected by IR sensor (LOW signal)");
      
      publishSensorData();
      
      // Auto open door if closed and not in manual override
      if (!doorState && millis() > manualOverrideUntil) {
        Serial.println("Person detected - Auto opening door");
        moveDoorTo(DOOR_OPEN, "auto_open");
      }
    } else {
      // Person no longer detected (sensor HIGH)
      lastDistance = 0;
      Serial.println("Person no longer detected (HIGH signal)");
      publishSensorData();
    }
  }
}

void publishSensorData() {
  StaticJsonDocument<200> doc;
  doc["presence"] = presenceDetected;
  doc["distance"] = lastDistance;
  doc["sensor_type"] = "IR_digital";
  doc["signal_strength"] = WiFi.RSSI();
  doc["timestamp"] = millis() / 1000;
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  if (client.connected()) {
    client.publish(topic_sensor, jsonString.c_str());
  }
}

// === AUTOMATIC CONTROL ===
void checkAutomaticControl() {
  // Skip if in manual override mode
  if (millis() < manualOverrideUntil) {
    return;
  }
  
  // Auto close door if no person detected for PRESENCE_TIMEOUT
  if (doorState && !presenceDetected && 
      (millis() - lastPersonSeen) > PRESENCE_TIMEOUT) {
    Serial.println("No person detected for timeout - Auto closing door");
    moveDoorTo(DOOR_CLOSED, "auto_close");
  }
}

// === SERVO CONTROL ===
void moveDoorTo(int targetAngle, String action) {
  if (targetAngle < 0) targetAngle = 0;
  if (targetAngle > 90) targetAngle = 90;
  
  if (currentAngle == targetAngle) {
    Serial.println("Door already at target position");
    return;
  }
  
  Serial.printf("Moving door from %d° to %d°\n", currentAngle, targetAngle);
  lastAction = action;
  
  // Smooth movement
  int step = (targetAngle > currentAngle) ? 1 : -1;
  
  while (currentAngle != targetAngle) {
    currentAngle += step;
    doorServo.write(currentAngle);
    delay(SMOOTH_DELAY);
  }
  
  // Update door state
  doorState = (currentAngle > 45); // Consider open if > 45°
  
  Serial.printf("Door movement complete: %d° (%s)\n", 
                currentAngle, doorState ? "OPEN" : "CLOSED");
  
  // Publish status
  publishStatus();
}

// === MQTT FUNCTIONS ===
void reconnectMQTT() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    
    String clientId = "ESP32_SmartDoor_" + String(random(0xffff), HEX);
    
    if (client.connect(clientId.c_str(), mqtt_user, mqtt_pass)) {
      Serial.println(" connected!");
      
      // Subscribe to command topic
      client.subscribe(topic_cmd);
      Serial.printf("Subscribed to: %s\n", topic_cmd);
      
      // Send online status
      publishStatus();
      
    } else {
      Serial.printf(" failed, rc=%d. Retrying in 5 seconds...\n", client.state());
      delay(5000);
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String message;
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  
  Serial.printf("MQTT received [%s]: %s\n", topic, message.c_str());
  
  if (String(topic) == topic_cmd) {
    handleCommand(message);
  }
}

void handleCommand(String jsonMessage) {
  StaticJsonDocument<200> doc;
  DeserializationError error = deserializeJson(doc, jsonMessage);
  
  if (error) {
    Serial.println("JSON parsing failed");
    return;
  }
  
  String source = doc["source"] | "unknown";
  
  // Set manual override if command is from web/manual source
  if (source == "manual" || source == "button") {
    manualOverrideUntil = millis() + MANUAL_OVERRIDE;
    Serial.printf("Manual override activated for %d seconds\n", MANUAL_OVERRIDE/1000);
  }
  
  // Handle angle command
  if (doc.containsKey("angle")) {
    int targetAngle = doc["angle"];
    String action = "manual_" + String(targetAngle == DOOR_OPEN ? "open" : "close");
    moveDoorTo(targetAngle, action);
  }
  
  // Handle action command
  else if (doc.containsKey("action")) {
    String action = doc["action"];
    if (action == "open") {
      moveDoorTo(DOOR_OPEN, "manual_open");
    } else if (action == "close") {
      moveDoorTo(DOOR_CLOSED, "manual_close");
    }
  }
}

void publishStatus() {
  StaticJsonDocument<300> doc;
  
  doc["angle"] = currentAngle;
  doc["state"] = doorState ? "open" : "closed";
  doc["presence"] = presenceDetected;
  doc["distance"] = lastDistance;
  doc["secs_since_seen"] = (millis() - lastPersonSeen) / 1000;
  doc["last_action"] = lastAction;
  doc["manual_override"] = (millis() < manualOverrideUntil);
  doc["uptime"] = millis() / 1000;
  doc["free_heap"] = ESP.getFreeHeap();
  doc["wifi_rssi"] = WiFi.RSSI();
  doc["timestamp"] = millis() / 1000;
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  if (client.connected()) {
    client.publish(topic_status, jsonString.c_str());
    Serial.println("Status published");
  }
}

void sendHeartbeat() {
  StaticJsonDocument<100> doc;
  doc["heartbeat"] = true;
  doc["uptime"] = millis() / 1000;
  doc["free_heap"] = ESP.getFreeHeap();
  doc["timestamp"] = millis() / 1000;
  
  String jsonString;
  serializeJson(doc, jsonString);
  
  if (client.connected()) {
    client.publish(topic_status, jsonString.c_str());
  }
}

// === DEBUG FUNCTIONS ===
void printSystemInfo() {
  Serial.println("\n=== System Status ===");
  Serial.printf("Door Angle: %d° (%s)\n", currentAngle, doorState ? "OPEN" : "CLOSED");
  Serial.printf("Presence: %s\n", presenceDetected ? "YES" : "NO");
  Serial.printf("Distance: %.2fm\n", lastDistance);
  Serial.printf("Time since person: %lu seconds\n", (millis() - lastPersonSeen) / 1000);
  Serial.printf("Manual override: %s\n", (millis() < manualOverrideUntil) ? "ACTIVE" : "INACTIVE");
  Serial.printf("WiFi RSSI: %d dBm\n", WiFi.RSSI());
  Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
  Serial.printf("Uptime: %lu seconds\n", millis() / 1000);
  Serial.println("==================\n");
}
